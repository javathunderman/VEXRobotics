#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  Jumper1,        sensorDigitalIn)
#pragma config(Sensor, dgtl2,  Jumper2,        sensorDigitalIn)
#pragma config(Sensor, dgtl3,  Jumper3,        sensorDigitalIn)
#pragma config(Sensor, dgtl4,  Jumper4,        sensorDigitalIn)
#pragma config(Sensor, dgtl5,  Jumper5,        sensorDigitalIn)
#pragma config(Sensor, dgtl6,  Quad,           sensorQuadEncoder)
#pragma config(Motor,  port2,           leftside,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightside,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm3,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(3.0)
#pragma userControlDuration(9.0)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int QuadReset;
int Quad1;
void pre_auton()
{

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
	QuadReset = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


task autonomous()
{
	/*
	motor[leftside]=-127;
	motor[rightside]=-127;
	wait(0.1);

	motor[claw]=127;
	wait(0.5); //unknown time//

	motor[claw]=0;


	motor[leftside]= 127;
	motor[rightside]= 127;

	wait(1.5);

	motor[leftside]=0;
	motor[rightside]= 0;


	motor[claw]=-127;
	wait(0.5); //unknown time//

	motor[rightside]=127;
	motor[leftside]=-127;
	wait(0.9);

	motor[rightside]=127;
	motor[leftside]=127;
	wait(0.9);

	motor[rightside]=0;
	motor[leftside]=0;

	motor[rightside]=127;
	motor[leftside]=-127;
	wait(0.8);

	motor[rightside]=-127;
	motor[leftside]=-127;
	wait(0.9);

	motor[rightside]=0;
	motor[leftside]=0;

	motor[arm]=-127;
	motor[arm2]=-127;
	motor[arm3]=-127;
	wait(1.6*.6); //unknown time//

	motor[arm]=0;
	motor[arm2]=0;
	motor[arm3]=0;

	motor[claw]=127;
	wait(0.3);

	motor[claw]=0;

	*/

	if(SensorValue(Jumper1) == 0)
	{
		motor[leftside]=-127; ///////////////for right side//
		motor[rightside]=-127;
		wait(0.2);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(.1); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[claw]=127;
		wait(0.5); //unknown time//

		motor[claw]=0;

		motor[leftside]=-127;
		motor[rightside]=-127;
		wait(1.35); //unknown time//

		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.6); //unknown time//
		motor[arm]=127;
		motor[arm2]=127;
		motor[arm3]=127;
		wait(.33); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;
		motor[leftside]=127;
		motor[rightside]=127;
		wait(0.6); //unknown time same as above//

		motor[leftside]=0;
		motor[rightside]=0;





		motor[rightside]=-127;
		motor[leftside]=127;
		wait(0.80/2); //quarter turn//

		motor[leftside]=127;
		motor[rightside]=127;
		wait(1.6);

		motor[rightside]=0;
		motor[leftside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(.05);
		motor[claw]=-127;
		wait(0.5); //same as earlier but opposite//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;


		motor[rightside]=127;
		motor[leftside]=-127;
		wait(1.3/2); //quarter turn//


		motor[leftside]=0;
		motor[rightside]=0;

		motor[rightside]=-127;
		motor[leftside]=-127;
		wait(1.0);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.5);

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;
		motor[claw]=127;
		wait(0.5);

		motor[claw]=0;
	}
	if(SensorValue(Jumper2)==0)
	{
		motor[leftside]=-127; /////////// for left side//
		motor[rightside]=-127;
		wait(0.2);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(.1); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[claw]=127;
		wait(0.5); //unknown time//

		motor[claw]=0;

		motor[leftside]=-127;
		motor[rightside]=-127;
		wait(1.35); //unknown time//

		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.6); //unknown time//
		motor[arm]=127;
		motor[arm2]=127;
		motor[arm3]=127;
		wait(.33); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;
		motor[leftside]=127;
		motor[rightside]=127;
		wait(0.6); //unknown time same as above//

		motor[leftside]=0;
		motor[rightside]=0;





		motor[rightside]=127;
		motor[leftside]=-127;
		wait(0.80/2); //quarter turn//

		motor[leftside]=127;
		motor[rightside]=127;
		wait(1.6);

		motor[rightside]=0;
		motor[leftside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(.05);
		motor[claw]=-127;
		wait(0.5); //same as earlier but opposite//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;


		motor[rightside]=-127;
		motor[leftside]=127;
		wait(1.3/2); //quarter turn//


		motor[leftside]=0;
		motor[rightside]=0;

		motor[rightside]=-127;
		motor[leftside]=-127;
		wait(1.0);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.5);

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;
		motor[claw]=127;
		wait(0.5);

		motor[claw]=0;

		if(SensorValue(Jumper3) == 0) //// left not cube///
		{

			wait(5);
			motor[leftside]=-80;
			motor[rightside]=-127;
			wait(0.1);

			motor[claw]=127;
			wait(0.5); //unknown time//

			motor[claw]=0;
			motor[arm]=50;
			motor[arm2]=50;
			motor[arm3]=50;
			wait(.15);


			motor[leftside]= 80;
			motor[rightside]= 127;

			wait(2.4);

			motor[leftside]=0;
			motor[rightside]= 0;


			motor[claw]=-127;
			wait(0.5); //unknown time//

			motor[rightside]=127; ///45
			wait(2.1);

			motor[rightside]=127;
			motor[leftside]=127;
			wait(0.9);

			motor[rightside]=0;
			motor[leftside]=0;

			motor[rightside]=127; //90//
			motor[leftside]=-127;
			wait(1.2);

			motor[rightside]=-127;
			motor[leftside]=-127;
			wait(0.9);

			motor[rightside]=0;
			motor[leftside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.6*.6); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[claw]=127;
			wait(0.3);

			motor[claw]=0;
		}
		if(SensorValue(Jumper4) == 0) //not cube right
		{
			wait(5);
			motor[leftside]=-80;
			motor[rightside]=-127;
			wait(0.1);

			motor[claw]=127;
			wait(0.5); //unknown time//

			motor[claw]=0;
			motor[arm]=50;
			motor[arm2]=50;
			motor[arm3]=50;
			wait(.15);


			motor[leftside]= 80;
			motor[rightside]= 127;

			wait(2.4);

			motor[leftside]=0;
			motor[rightside]= 0;


			motor[claw]=-127;
			wait(0.5); //unknown time//

			motor[leftside]=127; ///45
			wait(2.1);

			motor[rightside]=127;
			motor[leftside]=127;
			wait(0.9);

			motor[rightside]=0;
			motor[leftside]=0;

			motor[rightside]=-127; //90//
			motor[leftside]=127;
			wait(1.2);

			motor[rightside]=-127;
			motor[leftside]=-127;
			wait(0.9);

			motor[rightside]=0;
			motor[leftside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.6*.6); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[claw]=127;
			wait(0.3);

			motor[claw]=0;
		}
	 if(SensorValue(Jumper5)== 0)
		{

		motor[leftside]=-127; ///////////////for right side//
		motor[rightside]=-127;
		wait(0.2);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(.1); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[claw]=127;
		wait(0.5); //unknown time//

		motor[claw]=0;

		motor[leftside]=-127;
		motor[rightside]=-127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == -1260);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.6); //unknown time//
		motor[arm]=127;
		motor[arm2]=127;
		motor[arm3]=127;
		wait(.33); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == 576);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[claw]=127;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == -576);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.6); //unknown time//
		motor[claw]=-127;
		wait(0.5);
		motor[arm]=127;
		motor[arm2]=127;
		motor[arm3]=127;
		wait(.33); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == 576);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[claw]=127;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == -576);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.6); //unknown time//
		motor[claw]=-127;
		wait(0.5);
		motor[arm]=127;
		motor[arm2]=127;
		motor[arm3]=127;
		wait(.33); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == 576);
		motor[leftside]=0;
		motor[rightside]=0;

		motor[claw]=127;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == -576);

		motor[leftside]=0;
		motor[rightside]=0;


		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.6); //unknown time//
		motor[claw]=-127;
		wait(0.5);
		motor[arm]=127;
		motor[arm2]=127;
		motor[arm3]=127;
		wait(.33); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == 540);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[leftside]=127;
		motor[rightside]=-127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == -360);

		motor[leftside]=0;
		motor[rightside]=0;


		motor[leftside]=127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == 1260);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[claw]= 127;

		motor[leftside]=-127;
		motor[rightside]=127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == 360);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[leftside]=-127;
		motor[rightside]=-127;
		SensorValue(Quad) = (QuadReset);
		waitUntil(SensorValue(Quad) == -360);

		motor[leftside]=0;
		motor[rightside]=0;

		motor[arm]=-127;
		motor[arm2]=-127;
		motor[arm3]=-127;
		wait(1.55*.9); //unknown time//

		motor[arm]=0;
		motor[arm2]=0;
		motor[arm3]=0;

		motor[claw]=-127;
		wait(0.5);

		motor[claw]=0;

		}
	}
}

//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop //

	while(1==1)
	{
	Quad1 = in6;

		motor[rightside] = vexRT[Ch2];
		motor[leftside] = vexRT[Ch3];

		if (vexRT[Btn7UXmtr2]==1)
		{
			motor[arm]=-25;
			motor[arm2]=-25;
			motor[arm3]=-25;
		}
		if(vexRT[Btn6UXmtr2]==1)
		{
			motor[claw]=127;
		}


		else if(vexRT[Btn5UXmtr2]==1)
		{
			motor[claw]=-127;
		}
		else if(vexRT[Btn5UXmtr2]==0)
		{
			motor[claw]=0;
		}
		////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////

		if(vexRT[Btn6DXmtr2]==1) ///claw goes up//
		{
			motor[arm]=127;
			motor[arm2]=127;
			motor[arm3]=127;
		}


		else if(vexRT[Btn5DXmtr2]==1) ///claw goes down///
		{
			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
		}
		else if(vexRT[Btn5DXmtr2]==0)
		{
			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;///end claw goes down///
		}

		if(vexRT[Btn7DXmtr2]==1)
		{
			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;
		}

		if(vexRT[Btn8D]==1)
		{
			/*	motor[leftside]=-127; ///////////////for right side//
			motor[rightside]=-127;
			wait(0.2);

			motor[leftside]=0;
			motor[rightside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(.1); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[claw]=127;
			wait(0.5); //unknown time//

			motor[claw]=0;

			motor[leftside]=-127;
			motor[rightside]=-127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == -1260);
			motor[leftside]=0;
			motor[rightside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.55*.6); //unknown time//
			motor[arm]=127;
			motor[arm2]=127;
			motor[arm3]=127;
			wait(.33); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == 576);
			motor[leftside]=0;
			motor[rightside]=0;

			motor[claw]=127;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == -576);
			motor[leftside]=0;
			motor[rightside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.55*.6); //unknown time//
			motor[claw]=-127;
			wait(0.5);
			motor[arm]=127;
			motor[arm2]=127;
			motor[arm3]=127;
			wait(.33); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == 576);
			motor[leftside]=0;
			motor[rightside]=0;

			motor[claw]=127;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == -576);
			motor[leftside]=0;
			motor[rightside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.55*.6); //unknown time//
			motor[claw]=-127;
			wait(0.5);
			motor[arm]=127;
			motor[arm2]=127;
			motor[arm3]=127;
			wait(.33); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == 576);
			motor[leftside]=0;
			motor[rightside]=0;

			motor[claw]=127;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == -576);

			motor[leftside]=0;
			motor[rightside]=0;


			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.55*.6); //unknown time//
			motor[claw]=-127;
			wait(0.5);
			motor[arm]=127;
			motor[arm2]=127;
			motor[arm3]=127;
			wait(.33); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == 540);

			motor[leftside]=0;
			motor[rightside]=0;

			motor[leftside]=127;
			motor[rightside]=-127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == -360);

			motor[leftside]=0;
			motor[rightside]=0;


			motor[leftside]=127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == 1260);

			motor[leftside]=0;
			motor[rightside]=0;

			motor[claw]= 127;

			motor[leftside]=-127;
			motor[rightside]=127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == 360);

			motor[leftside]=0;
			motor[rightside]=0;

			motor[leftside]=-127;
			motor[rightside]=-127;
			SensorValue(Quad) = (QuadReset);
			waitUntil(SensorValue(Quad) == -360);

			motor[leftside]=0;
			motor[rightside]=0;

			motor[arm]=-127;
			motor[arm2]=-127;
			motor[arm3]=-127;
			wait(1.55*.9); //unknown time//

			motor[arm]=0;
			motor[arm2]=0;
			motor[arm3]=0;

			motor[claw]=-127;
			wait(0.5);

			motor[claw]=0;


			} */
		}

	}
}
