#pragma config(Sensor, dgtl1,  Solenoid,       sensorDigitalOut)
#pragma config(Motor,  port2,           mDriveL,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           mDriveL2,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           mDriveR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           mDriveR2,      tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//*!		      Author: Ethan Lin		          !*//
//*!		       Copyright 2017	   	          !*//

//----------------------------------------------------------//
//	  I have added temporary Pneumatics control 	    //
//	      Problem: Btn6U ==1, solenoid = 1		    //
//		       Btn6U ==0, solenoid = 0	 	    //
//							    //
//          !!ARJUN, PLEASE FIX  task newmatics()!!         //
//----------------------------------------------------------//


const int joy_threshold = 10; // maximum error +/- of joysticks when released

// compensates for non-linearity of control value vs speed curve
const unsigned int TrueSpeed[128] =
{
	0,  9,  9,  9, 10, 10, 10, 10, 11, 11,
	11, 11, 12, 12, 12, 12, 12, 13, 13, 13,
	13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
	16, 16, 17, 17, 17, 18, 18, 18, 18, 19,
	19, 19, 20, 20, 20, 21, 21, 21, 22, 22,
	22, 23, 23, 23, 24, 24, 24, 25, 25, 26,
	26, 27, 27, 27, 28, 28, 28, 29, 29, 30,
	30, 31, 31, 32, 32, 33, 33, 34, 34, 35,
	36, 36, 37, 37, 38, 38, 39, 40, 40, 41,
	42, 43, 44, 45, 45, 46, 47, 48, 49, 50,
	51, 52, 54, 55, 55, 57, 59, 61, 63, 65,
	67, 70, 72, 74, 76, 80, 84, 88, 93, 97,
	101,106,108,111,114,119,124,127
};

task UserDrive()
{
	float left_drive_pwr;
	float right_drive_pwr;

	while(1)
	{
		left_drive_pwr = vexRT[Ch3];
		right_drive_pwr = vexRT[Ch2];

		//** linear speed control with threshold

		// left
		if(left_drive_pwr > joy_threshold)
			left_drive_pwr = TrueSpeed[left_drive_pwr];
		else if(left_drive_pwr < -joy_threshold)
			left_drive_pwr = -TrueSpeed[-left_drive_pwr];
		else
			left_drive_pwr = 0;

		// right
		if(right_drive_pwr > joy_threshold)
			right_drive_pwr = TrueSpeed[right_drive_pwr];
		else if(right_drive_pwr < -joy_threshold)
			right_drive_pwr = -TrueSpeed[-right_drive_pwr];
		else
			right_drive_pwr = 0;

		// "precise control" buttons
		if(vexRT[Btn5D] + vexRT[Btn5U] + vexRT[Btn6D] + vexRT[Btn6U] > 0)
		{
			left_drive_pwr *= 0.7;
			right_drive_pwr *= 0.7;
		}

		//** antijerk

		// left
		if(left_drive_pwr > motor[mDriveL])
			motor[mDriveL] += 1;
		else if(left_drive_pwr < motor[mDriveL])
			motor[mDriveL] -= 1;
		motor[mDriveL2] = motor[mDriveL];

		// right
		if(right_drive_pwr > motor[mDriveR])
			motor[mDriveR] += 1;
		else if(right_drive_pwr < motor[mDriveR])
			motor[mDriveR] -= 1;
		motor[mDriveR2] = motor[mDriveR];

		wait1Msec(1);
	}
}

task newmatics() //this is temporary. we need the solenoid to stay up after you press the button and after you release it, and the solenoid needs to do down after another button input. 
{
	while(true) //loop forever
	{
		if(vexRT[Btn6U] == 1) //if button 6 is pressed
		{
			SensorValue[Solenoid] = 1; //activate solenoid
		}
		else //if button 6 is NOT pressed
		{
			SensorValue[Solenoid] = 0; //deactivate solenoid
		}
	}
}

task main() { //initialize the main task
	while(true) { //keep listening for new VexNet input
	startTask(UserDrive); //keep referring back to the manual control algorithm
	startTask(newmatics); //Yes. It's spelled wrong
}
}
