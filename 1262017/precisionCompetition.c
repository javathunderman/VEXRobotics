#pragma config(Sensor, dgtl1,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           mDriveL,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           mDriveL2,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           mDriveR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           mDriveR2,      tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#pragma platform(VEX2)


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

const int joy_threshold = 10; // maximum error +/- of joysticks when released

// compensates for non-linearity of control value vs speed curve
const unsigned int TrueSpeed[128] =
{
	0,  9,  9,  9, 10, 10, 10, 10, 11, 11,
	11, 11, 12, 12, 12, 12, 12, 13, 13, 13,
	13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
	16, 16, 17, 17, 17, 18, 18, 18, 18, 19,
	19, 19, 20, 20, 20, 21, 21, 21, 22, 22,
	22, 23, 23, 23, 24, 24, 24, 25, 25, 26,
	26, 27, 27, 27, 28, 28, 28, 29, 29, 30,
	30, 31, 31, 32, 32, 33, 33, 34, 34, 35,
	36, 36, 37, 37, 38, 38, 39, 40, 40, 41,
	42, 43, 44, 45, 45, 46, 47, 48, 49, 50,
	51, 52, 54, 55, 55, 57, 59, 61, 63, 65,
	67, 70, 72, 74, 76, 80, 84, 88, 93, 97,
	101,106,108,111,114,119,124,127
};
void pre_auton()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[solenoid] = 0;
}

task autonomous()
{
	while(SensorValue[rightEncoder] >-1080 && SensorValue[leftEncoder] < 1140) {
		motor[mDriveL] = 63;
		motor[mDriveL2] = 63;
		motor[mDriveR] = 63;
		motor[mDriveR] = 63;
	}
	motor[mDriveL] = 63;
		motor[mDriveL2] = 63;
		motor[mDriveR] = 63;
		motor[mDriveR] = 63;

}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task PrecisionControl() {
	float left_drive_pwr;
	float right_drive_pwr;

	while(1)
	{
		left_drive_pwr = vexRT[Ch3];
		right_drive_pwr = vexRT[Ch2];

		//** linear speed control with threshold

		// left
		if(left_drive_pwr > joy_threshold)
			left_drive_pwr = TrueSpeed[left_drive_pwr];
		else if(left_drive_pwr < -joy_threshold)
			left_drive_pwr = -TrueSpeed[-left_drive_pwr];
		else
			left_drive_pwr = 0;

		// right
		if(right_drive_pwr > joy_threshold)
			right_drive_pwr = TrueSpeed[right_drive_pwr];
		else if(right_drive_pwr < -joy_threshold)
			right_drive_pwr = -TrueSpeed[-right_drive_pwr];
		else
			right_drive_pwr = 0;

		// "precise control" buttons
		if(vexRT[Btn5D] + vexRT[Btn5U] + vexRT[Btn6D] + vexRT[Btn6U] > 0)
		{
			left_drive_pwr *= 0.7;
			right_drive_pwr *= 0.7;
		}

		//** antijerk

		// left
		if(left_drive_pwr > motor[mDriveL])
			motor[mDriveL] += 1;
		else if(left_drive_pwr < motor[mDriveL])
			motor[mDriveL] -= 1;
		motor[mDriveL2] = motor[mDriveL];

		// right
		if(right_drive_pwr > motor[mDriveR])
			motor[mDriveR] += 1;
		else if(right_drive_pwr < motor[mDriveR])
			motor[mDriveR] -= 1;
		motor[mDriveR2] = motor[mDriveR];

		wait1Msec(1);
	}
}

task newmatics() //start pneumatics
{
	int i;
	i = 0;
	while(true)
	{
		if(vexRT[Btn6U] == 1)
		{
			i++;
		}
		if((i % 2) == 0)
		{
			SensorValue[solenoid] = 0;
		}
		else {
			SensorValue[solenoid] = 1;
		}
	}
}

task usercontrol()
{

	startTask(PrecisionControl);
	// Start Newmatics
	startTask(newmatics);

	// Everything done in other tasks
	while( true )
	{
		wait1Msec( 100 );
	}
}
