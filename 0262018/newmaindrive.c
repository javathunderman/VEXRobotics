#pragma config(Motor,  port2,           mDriveL,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           mDriveL2,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           mDriveR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           mDriveR2,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           liftLeft,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           liftRight,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify
#pragma platform(VEX2)

void pre_auton() {
}
task autonomous() {
	motor[mDriveL] = 127;
	motor[mDriveR] = 127;
	motor[mDriveL2] = 127;
	motor[mDriveR2] = 127;
	wait(10);
	motor[mDriveL] = 0;
	motor[mDriveL2] = 0;
	motor[mDriveR] = 0;
	motor[mDriveR2] = 0;
}


#define     JOY_DRIVE_V     vexJSLeftV
#define     JOY_DRIVE_H     vexJSLeftH
#define     JOY_THRESHOLD   15

#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

const int joy_threshold = 10; // maximum error +/- of joysticks when released

// compensates for non-linearity of control value vs speed curve
const unsigned int TrueSpeed[128] =
{
	0,  9,  9,  9, 10, 10, 10, 10, 11, 11,
	11, 11, 12, 12, 12, 12, 12, 13, 13, 13,
	13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
	16, 16, 17, 17, 17, 18, 18, 18, 18, 19,
	19, 19, 20, 20, 20, 21, 21, 21, 22, 22,
	22, 23, 23, 23, 24, 24, 24, 25, 25, 26,
	26, 27, 27, 27, 28, 28, 28, 29, 29, 30,
	30, 31, 31, 32, 32, 33, 33, 34, 34, 35,
	36, 36, 37, 37, 38, 38, 39, 40, 40, 41,
	42, 43, 44, 45, 45, 46, 47, 48, 49, 50,
	51, 52, 54, 55, 55, 57, 59, 61, 63, 65,
	67, 70, 72, 74, 76, 80, 84, 88, 93, 97,
	101,106,108,111,114,119,124,127
};

task UserDrive()
{
	float left_drive_pwr;
	float right_drive_pwr;

	while(1)
	{
		left_drive_pwr = vexRT[Ch3];
		right_drive_pwr = vexRT[Ch2];

		//** linear speed control with threshold

		// left
		if(left_drive_pwr > joy_threshold)
			left_drive_pwr = TrueSpeed[left_drive_pwr];
		else if(left_drive_pwr < -joy_threshold)
			left_drive_pwr = -TrueSpeed[-left_drive_pwr];
		else
			left_drive_pwr = 0;

		// right
		if(right_drive_pwr > joy_threshold)
			right_drive_pwr = TrueSpeed[right_drive_pwr];
		else if(right_drive_pwr < -joy_threshold)
			right_drive_pwr = -TrueSpeed[-right_drive_pwr];
		else
			right_drive_pwr = 0;

		// "precise control" buttons
		if(vexRT[Btn5D] + vexRT[Btn5U] + vexRT[Btn6D] + vexRT[Btn6U] > 0)
		{
			left_drive_pwr *= 0.7;
			right_drive_pwr *= 0.7;
		}

		//** antijerk

		// left
		if(left_drive_pwr > motor[mDriveL])
			motor[mDriveL] += 1;
		else if(left_drive_pwr < motor[mDriveL])
			motor[mDriveL] -= 1;
		motor[mDriveL2] = motor[mDriveL];

		// right
		if(right_drive_pwr > motor[mDriveR])
			motor[mDriveR] += 1;
		else if(right_drive_pwr < motor[mDriveR])
			motor[mDriveR] -= 1;
		motor[mDriveR2] = motor[mDriveR];

		wait1Msec(1);
	}
}

task liftControl() {
	while(true) {
	motor[liftLeft] = vexRT[Ch2Xmtr2];
	motor[liftRight] = vexRT[Ch3Xmtr2];
}
}

task usercontrol() {
	while (true) {
	startTask(UserDrive);
	startTask(liftControl);
}
}
