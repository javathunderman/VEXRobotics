#pragma config(Sensor, dgtl1,  Solenoid,       sensorDigitalOut)
#pragma config(Motor,  port2,           liftArm,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           mDriveL,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           mDriveL2,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           mDriveR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           mDriveR2,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int joy_threshold = 10; // maximum error +/- of joysticks when released

// compensates for non-linearity of control value vs speed curve
const unsigned int TrueSpeed[128] =
{
	0,  9,  9,  9, 10, 10, 10, 10, 11, 11,
	11, 11, 12, 12, 12, 12, 12, 13, 13, 13,
	13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
	16, 16, 17, 17, 17, 18, 18, 18, 18, 19,
	19, 19, 20, 20, 20, 21, 21, 21, 22, 22,
	22, 23, 23, 23, 24, 24, 24, 25, 25, 26,
	26, 27, 27, 27, 28, 28, 28, 29, 29, 30,
	30, 31, 31, 32, 32, 33, 33, 34, 34, 35,
	36, 36, 37, 37, 38, 38, 39, 40, 40, 41,
	42, 43, 44, 45, 45, 46, 47, 48, 49, 50,
	51, 52, 54, 55, 55, 57, 59, 61, 63, 65,
	67, 70, 72, 74, 76, 80, 84, 88, 93, 97,
	101,106,108,111,114,119,124,127
};

task UserDrive()
{
	float left_drive_pwr;
	float right_drive_pwr;

	while(1)
	{
		left_drive_pwr = vexRT[Ch3];
		right_drive_pwr = vexRT[Ch2];

		//** linear speed control with threshold

		// left
		if(left_drive_pwr > joy_threshold)
			left_drive_pwr = TrueSpeed[left_drive_pwr];
		else if(left_drive_pwr < -joy_threshold)
			left_drive_pwr = -TrueSpeed[-left_drive_pwr];
		else
			left_drive_pwr = 0;

		// right
		if(right_drive_pwr > joy_threshold)
			right_drive_pwr = TrueSpeed[right_drive_pwr];
		else if(right_drive_pwr < -joy_threshold)
			right_drive_pwr = -TrueSpeed[-right_drive_pwr];
		else
			right_drive_pwr = 0;

		// "precise control" buttons
		if(vexRT[Btn5D] + vexRT[Btn5U] + vexRT[Btn6D] + vexRT[Btn6U] > 0)
		{
			left_drive_pwr *= 0.7;
			right_drive_pwr *= 0.7;
		}

		//** antijerk

		// left
		if(left_drive_pwr > motor[mDriveL])
			motor[mDriveL] += 1;
		else if(left_drive_pwr < motor[mDriveL])
			motor[mDriveL] -= 1;
		motor[mDriveL2] = motor[mDriveL];

		// right
		if(right_drive_pwr > motor[mDriveR])
			motor[mDriveR] += 1;
		else if(right_drive_pwr < motor[mDriveR])
			motor[mDriveR] -= 1;
		motor[mDriveR2] = motor[mDriveR];

		wait1Msec(1);
	}
}
task liftControl() {
	if(vexRT[Btn6U] == 1) {
		motor[liftArm] = -127;
	}
	else {
		motor[liftArm] = 0;
	}
	if(vexRT[Btn5U] = 1) {
		motor[liftArm] = 127;
	}
	else {
		motor[liftArm] = 0;
	}
}
task main() { //initialize the main task
	while(true) { //keep listening for new VexNet input
	startTask(UserDrive); //keep referring back to the manual control algorithm
	startTask(liftControl);
}
}
