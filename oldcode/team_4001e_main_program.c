#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl2,  NoSensor,       sensorDigitalOut)
#pragma config(Sensor, dgtl7,  BackEN,         sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  LeftClaw,       sensorDigitalOut)
#pragma config(Sensor, dgtl10, RightClaw,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, RightEN,        sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  FrontEN,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  RightLiftEN,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  BackEN,         sensorNone)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightMotor,    tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl11)
#pragma config(Motor,  port4,           BackMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           FrontMotor,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port6,           Lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Lift2,         tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           Lift1b,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Lift2b,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


bool LeftPiston = true;
bool RightPiston = true;




/////////////Methods start://////////////////////////////////////////////////////////////////////////////////////////

void LinearMovement()
{
//Linear movement code : Forward, Left, Right, and Back with left stick
		motor(LeftMotor)=-vexRT[Ch3];
		motor(RightMotor)=-vexRT[Ch3];
		motor(FrontMotor)=vexRT[Ch4];
		motor(BackMotor)=vexRT[Ch4];
}

void Rotation()
{
//Rotation movement code: When 6D is pressed, move right joystick left and right to rotate left and right
	while(vexRT[Btn6D]==1)
	{
		motor(LeftMotor)=-vexRT[Ch1];
		motor(RightMotor)=vexRT[Ch1];
		motor(FrontMotor)=vexRT[Ch1];
		motor(BackMotor)=-vexRT[Ch1];

	}
}

void LiftControl()
{

//Lift control: use buttons 5D and 5U to move up and down////Lift max: 8100
	if(vexRT[Btn5U]==1)
	{
//		if(SensorValue[FrontEN]<8150 || vexRT[Btn7U]==1)
//		{
			motor(Lift1)=127;
			motor(Lift2)=127;
			motor(Lift1b)=127;
			motor(Lift2b)=127;
		}
//		else
//		{
//			motor(Lift1)=0;
//			motor(Lift2)=0;
//			motor(Lift1b)=0;
//			motor(Lift2b)=0;
//		}
//	}
	else if(vexRT[Btn5D]==1)
	{
//		if(SensorValue[FrontEN]>-5 || vexRT[Btn7D]==1)
//		{
			motor(Lift1)=-127;
			motor(Lift2)=-127;
			motor(Lift1b)=-127;
			motor(Lift2b)=-127;
		}
//		else
//		{
//			motor(Lift1)=0;
//			motor(Lift2)=0;
//			motor(Lift1b)=0;
//			motor(Lift2b)=0;
////	}
//	}
	else
	{
		motor(Lift1)=0;
		motor(Lift2)=0;
		motor(Lift1b)=0;
		motor(Lift2b)=0;
	}
}


void SkyrisePickup()
{
//skyrise pickup height
//Button that lifts to skyrise pickup height,
if(vexRT(Btn6U) == 1)
{
	while(SensorValue(FrontEN) < 1000 && (vexRT(Btn8D) == 0))
	{
		motor(Lift1) = 127;
		motor(Lift2) = 127;
		motor(Lift1b)=127;
		motor(Lift2b)=127;
		LinearMovement();
		Rotation();
	//	PistonClaws();
	}
	while(SensorValue(FrontEN) > 1000 && (vexRT(Btn8D) == 0))
	{
		motor(Lift1) = -127;
		motor(Lift2) = -127;
		motor(Lift1b)=-127;
		motor(Lift2b)=-127;
		LinearMovement();
		Rotation();
//		PistonClaws();
	}
}
}

void PistonClaws()
{
	SensorValue[LeftClaw]=1;
	if (vexRT[Btn7R]==1)
	{
	LeftPiston = true;
	}
	if (vexRT[Btn7L]==1)
	{
	LeftPiston = false;
	}
	if (LeftPiston)
	{
	SensorValue[LeftClaw]=1;
	}
	else
	{
	SensorValue[LeftClaw]=0;
	LeftPiston = false;
	}

	SensorValue[RightClaw]=1;
	if (vexRT[Btn8L]==1)
	{
	RightPiston = true;
	}
	if (vexRT[Btn8R]==1)
	{
	RightPiston = false;
	}
	if (RightPiston)
	{
	SensorValue[RightClaw]=1;
	}
	else
	{
	SensorValue[RightClaw]=0;
	RightPiston = false;
	}
}


void chooseAuton(int name)
{
	if(name == 0)////////////////BLUE SKYRISE PROGRAM////////////////////////////////////////////////////////
	{
		clearTimer(T1);


//Put in the cube
while(SensorValue[RightEN]<90)
{
	motor(LeftMotor)=127;
	motor(RightMotor)=127;
	//Close the claw
	SensorValue[RightClaw]=1;
}
	motor(LeftMotor)=0;
	motor(RightMotor)=0;
	wait1Msec(100);

	//Open the claw
SensorValue[RightClaw]=0;
wait1Msec(75);

//Slight forward movement
while(SensorValue[RightEN]>72)
{
	motor(LeftMotor)=-127;
	motor(RightMotor)=-127;
	//Close the claw
SensorValue[RightClaw]=1;
}
	motor(LeftMotor)=0;
	motor(RightMotor)=0;
	wait1Msec(100);

//Lift up goes to grab skyrise
while(SensorValue[FrontEN]<900)
{
	motor(Lift1)=127;
	motor(Lift2)=127;
	motor(Lift1b)=127;
	motor(Lift2b)=127;
	//Open the claw
	SensorValue[RightClaw]=0;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Move to grab skyrise
	while(SensorValue[BackEN]<128)
{
	motor(BackMotor)=127;
	motor(FrontMotor)=127;
}
	motor(FrontMotor)=0;
	motor(BackMotor)=0;
wait1Msec(250);

//Close the claw
SensorValue[RightClaw]=1;
wait1Msec(75);

//Lift up further
while(SensorValue[FrontEN]<2200)
{
	motor(Lift1)=127;
	motor(Lift2)=127;
	motor(Lift1b)=127;
	motor(Lift2b)=127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Rotate to align with skyrise drop
while(SensorValue[BackEN]>-38)//last working: 8
	{
		motor(LeftMotor)=-127;
		motor(RightMotor)=127;
		motor(FrontMotor)=127;
		motor(BackMotor)=-127;
	}
		motor(LeftMotor)=0;
		motor(RightMotor)=0;
		motor(FrontMotor)=0;
		motor(BackMotor)=0;
wait1Msec(75);

/*
//Slight movement to the right //-20 to 12
while(SensorValue[BackEN]<-10)
{
*/
	motor(FrontMotor)=127;
	motor(BackMotor)=127;
	wait1Msec(210);
	motor(FrontMotor)=0;
	motor(BackMotor)=0;
wait1Msec(100);

//Lift goes down
while(SensorValue[FrontEN]>750)
{
	motor(Lift1)=-127;
	motor(Lift2)=-127;
	motor(Lift1b)=-127;
	motor(Lift2b)=-127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Open the claw
SensorValue[RightClaw]=0;
wait1Msec(75);

//////////////////////////////////////second skyrise program............................

//Lift up further
while(SensorValue[FrontEN]<1200)
{
	motor(Lift1)=127;
	motor(Lift2)=127;
	motor(Lift1b)=127;
	motor(Lift2b)=127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Rotate back to align with skyrise pickup
while(SensorValue[BackEN]<165)
	{
		motor(LeftMotor)=127;
		motor(RightMotor)=-127;
		motor(FrontMotor)=-127;
		motor(BackMotor)=127;
	}
		motor(LeftMotor)=0;
		motor(RightMotor)=0;
		motor(FrontMotor)=0;
		motor(BackMotor)=0;
wait1Msec(1350);//change to 1350

//Close the claw
SensorValue[RightClaw]=1;
wait1Msec(75);

//Lift up further
while(SensorValue[FrontEN]<3000)
{
	motor(Lift1)=127;
	motor(Lift2)=127;
	motor(Lift1b)=127;
	motor(Lift2b)=127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Rotate to align with skyrise drop
while(SensorValue[BackEN]>96)
	{
		motor(LeftMotor)=-127;
		motor(RightMotor)=	127;
		motor(FrontMotor)=127;
		motor(BackMotor)=-127;
	}
		motor(LeftMotor)=0;
		motor(RightMotor)=0;
		motor(FrontMotor)=0;
		motor(BackMotor)=0;
wait1Msec(75);



//move to the left
motor(FrontMotor)=-127;
motor(BackMotor)=-127;
wait1Msec(127);
motor(FrontMotor)=0;
motor(BackMotor)=0;





//Lift goes down
while(SensorValue[FrontEN]>1350)
{
	motor(Lift1)=-127;
	motor(Lift2)=-127;
	motor(Lift1b)=-127;
	motor(Lift2b)=-127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Open the claw
SensorValue[RightClaw]=0;
wait1Msec(75);

//move to the left
motor(FrontMotor)=-127;
motor(BackMotor)=-127;
wait1Msec(650);
motor(FrontMotor)=0;
motor(BackMotor)=0;
	}



	else if (name == 1)/////////////////////////////RED SKYRISE PROGRAM//////////////////////////
	{





		//Put in the cube
		while(SensorValue[RightEN]>-85)
		{
			motor(LeftMotor)=-127;
			motor(RightMotor)=-127;
		}
			motor(LeftMotor)=0;
			motor(RightMotor)=0;
			wait1Msec(100);

		//Close the claw
		SensorValue[RightClaw]=1;
		wait1Msec(125);

		//Open the claw
		SensorValue[RightClaw]=0;
		wait1Msec(125);

		//Close the claw
		SensorValue[RightClaw]=1;
		wait1Msec(125);

		//Lift up goes to grab skyrise
		while(SensorValue[FrontEN]<900)
		{
			motor(Lift1)=127;
			motor(Lift2)=127;
			motor(Lift1b)=127;
			motor(Lift2b)=127;
			//Open the claw
			SensorValue[RightClaw]=0;
		}
			motor(Lift1)=0;
			motor(Lift2)=0;
			motor(Lift1b)=0;
			motor(Lift2b)=0;
		wait1Msec(125);

		//Move to grab skyrise
			while(SensorValue[BackEN]<85)
		{
			motor(BackMotor)=127;
			motor(FrontMotor)=127;
		}
			motor(FrontMotor)=0;
			motor(BackMotor)=0;
		wait1Msec(75);

		//Close the claw
		SensorValue[RightClaw]=1;
		wait1Msec(75);

		//Lift up further
		while(SensorValue[FrontEN]<2200)
		{
			motor(Lift1)=127;
			motor(Lift2)=127;
			motor(Lift1b)=127;
			motor(Lift2b)=127;
		}
			motor(Lift1)=0;
			motor(Lift2)=0;
			motor(Lift1b)=0;
			motor(Lift2b)=0;
		wait1Msec(75);

		//Rotate to align with skyrise drop
		while(SensorValue[BackEN]<323)
			{
				motor(LeftMotor)=127;
				motor(RightMotor)=-127;
				motor(FrontMotor)=-127;
				motor(BackMotor)=127;
			}
				motor(LeftMotor)=0;
				motor(RightMotor)=0;
				motor(FrontMotor)=0;
				motor(BackMotor)=0;
		wait1Msec(75);

		/*
		//Slight movement to the right //-20 to 12
		while(SensorValue[BackEN]<-10)
		{

				motor(FrontMotor)=127;
			motor(BackMotor)=127;
			wait1Msec(210);
			motor(FrontMotor)=0;
			motor(BackMotor)=0;
		wait1Msec(100);
		*/

		//Lift goes down
		while(SensorValue[FrontEN]>698)
		{
			motor(Lift1)=-127;
			motor(Lift2)=-127;
			motor(Lift1b)=-127;
			motor(Lift2b)=-127;
		}
			motor(Lift1)=0;
			motor(Lift2)=0;
			motor(Lift1b)=0;
			motor(Lift2b)=0;
		wait1Msec(75);

		//Open the claw
		SensorValue[RightClaw]=0;
		wait1Msec(75);

		//................second skyrise program...........
		//Lift up further
		while(SensorValue[FrontEN]<1200)
		{
			motor(Lift1)=127;
			motor(Lift2)=127;
			motor(Lift1b)=127;
			motor(Lift2b)=127;
		}
			motor(Lift1)=0;
			motor(Lift2)=0;
			motor(Lift1b)=0;
			motor(Lift2b)=0;
wait1Msec(75);

//Rotate back to align with skyrise pickup
while(SensorValue[BackEN]>219)
	{
		motor(LeftMotor)=-60;
		motor(RightMotor)=60;
		motor(FrontMotor)=60;
		motor(BackMotor)=-60;
	}
		motor(LeftMotor)=0;
		motor(RightMotor)=0;
		motor(FrontMotor)=0;
		motor(BackMotor)=0;
wait1Msec(1350);//change to 1350

//Close the claw
SensorValue[RightClaw]=1;
wait1Msec(75);

//Lift up further
while(SensorValue[FrontEN]<3000)
{
	motor(Lift1)=127;
	motor(Lift2)=127;
	motor(Lift1b)=127;
	motor(Lift2b)=127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);

//Rotate to align with skyrise drop
while(SensorValue[BackEN]<351)
	{
		motor(LeftMotor)=85;
		motor(RightMotor)=-85;
		motor(FrontMotor)=-85;
		motor(BackMotor)=85;
	}
		motor(LeftMotor)=0;
		motor(RightMotor)=0;
		motor(FrontMotor)=0;
		motor(BackMotor)=0;
wait1Msec(75);



//Lift goes down
while(SensorValue[FrontEN]>1350)
{
	motor(Lift1)=-127;
	motor(Lift2)=-127;
	motor(Lift1b)=-127;
	motor(Lift2b)=-127;
}
	motor(Lift1)=0;
	motor(Lift2)=0;
	motor(Lift1b)=0;
	motor(Lift2b)=0;
wait1Msec(75);



//Open the claw
SensorValue[RightClaw]=0;
wait1Msec(75);


//slight movement to the right
motor(FrontMotor)=-127;
motor(BackMotor)=-127;
wait1Msec(450);
motor(FrontMotor)=0;
motor(BackMotor)=0;
wait1Msec(75);

	}


	else if (name == 2)///////////////////////post auton///////////////////////////////////////
	{

		while(SensorValue[FrontEN]<1850 && time1[T3]<8000)
		{
			motor(Lift1)=127;
			motor(Lift2)=127;
			motor(Lift1b)=127;
			motor(Lift2b)=127;
		}
			motor(Lift1)=0;
			motor(Lift2)=0;
			motor(Lift1b)=0;
			motor(Lift2b)=0;
		wait1Msec(75);

	motor(LeftMotor)=-127;
	motor(RightMotor)=-127;
	wait1Msec(2500);
	motor(LeftMotor)=0;
	motor(RightMotor)=0;
	}




	else if (name == 3)/////////////////Drive Away Program///////////////////////
	{
	motor(LeftMotor)=-127;
	motor(RightMotor)=-127;
	wait1Msec(2500);
	motor(LeftMotor)=0;
	motor(RightMotor)=0;
	}



	else if(name == 4)/////////////Program of nothingness//////////////////////
	{
	}


}

///////////////////Methods end/////////////////////////////////////////////////////////////////////////////////////////



void pre_auton()
{
	/*
	SensorValue[RightEN]=0;
	SensorValue[FrontEN]=0;
	SensorValue[BackEN]=0;
	*/
}


task autonomous()
{
	chooseAuton(0);
	/*
	Values:
	0 = Blue (2) Skyrise and Cube
	1 = Red (2) Skyrise and Cube
	2 = (1) Cube on a Post
	3 = Drive Away
	4 = Do nothing
	*/
}


task usercontrol()
{

////////////////////////////////Battery display program start//////////////////////////////////////////////////////
//bLCDBacklight = true;                                    // Turn on LCD Backlight
//string mainBattery, backupBattery;
////////////////////////////////Battery display program end//////////////////////////////////////////////////////


SensorValue[RightEN]=0;
SensorValue[BackEN]=0;
SensorValue[FrontEN]=0;
SensorValue[RightLiftEN]=0;

while(1==1)
{
		LinearMovement();
		Rotation();
		LiftControl();
		SkyrisePickup();
		PistonClaws();


////////////////////////////////Battery display program start//////////////////////////////////////////////////////
//		clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
//		clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

////Display the Primary Robot battery voltage
//displayLCDString(0, 0, "Primary: ");
//sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
//displayNextLCDString(mainBattery);

////Display the Backup battery voltage
//displayLCDString(1, 0, "Backup: ");
//sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
//displayNextLCDString(backupBattery);

////Short delay for the LCD refresh rate
//wait1Msec(2000);

////Display the Infor
//displayLCDString(0, 0, "Team 4001E");
//displayLCDString(1, 0, "Parkland High");

////Short delay for the LCD refresh rate
//wait1Msec(2000);


////////////////////////////////Battery display program end//////////////////////////////////////////////////////


}
}
